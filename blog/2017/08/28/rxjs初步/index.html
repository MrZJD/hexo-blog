<!-- -> 定义页面布局--><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta name="keywords" content="Mrzjd Mrzebra hexo IT font-end 前端 技术"><meta name="keywords" content="FRP,RxJS"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.8.0/github-markdown.min.css"><link rel="stylesheet" href="/blog/less/main.css"><link rel="icon" href="/blog/images/favicon.png"><title>rxjs初步</title><script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="/blog/js/article.js"></script></head><body><header class="header"><h1 class="logo"><a href="/blog/" style="background-image:url(/blog//images/zblog-logo.png);">zblog</a></h1><i class="icon-list fa fa-bars"></i></header><div class="list-container"><ul class="header-list"><li class="header-item"><a href="/blog" title="HOME">HOME</a></li><li class="header-item"><a href="/blog/archives" title="Archives">Archives</a></li><li class="header-item"><a href="https://github.com/mrzjd" title="Github">Github</a></li></ul><div class="list-close"><i class="icon-close fa fa-times-circle-o"></i></div></div><div class="content"><article><div class="title-box"><h1 class="title"><span class="arti-tag" style="background:#EC0C8E;">RxJS</span>rxjs初步</h1><div class="date"><i class="icon-calendar fa fa-calendar"></i><span class="time">2017.08.28</span></div></div><div class="article-text markdown-body"><p>官网这样介绍</p>
<blockquote>
<p>Rx: An API for asynchronous programming with observable streams</p>
</blockquote>
<p>文档中这样介绍</p>
<blockquote>
<p>ReactiveX 结合了 观察者模式、迭代器模式 和 使用集合的函数式编程，以满足以一种理想方式来管理事件序列所需要的一切</p>
</blockquote>
<h3 id="Rx-Programming-Model-编程范式"><a href="#Rx-Programming-Model-编程范式" class="headerlink" title="Rx Programming Model-编程范式"></a>Rx Programming Model-编程范式</h3><p style="display:block;">核心概念：Observable, Observer, Operator, Subscription, Subscriber</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var stream$ = Rx.Observable.create(subscriber); // 1 -&gt; 定义Observable</span><br><span class="line">stream$.opt().opt(); // 2 -&gt; 流操作 Operators操作符来操作数据流</span><br><span class="line"></span><br><span class="line">var subscription = stream$.subscribe(observer); // 3 -&gt; 订阅Observable -&gt; 开始观察数据流</span><br><span class="line">subscription.unsubscribe(); // 4 -&gt; (可选)停止观察</span><br></pre></td></tr></table></figure>
<h3 id="Observable-可观察对象"><a href="#Observable-可观察对象" class="headerlink" title="Observable - 可观察对象"></a>Observable - 可观察对象</h3><ul>
<li>在同一 Observable 的多个观察者之间是不共享的 -&gt; 即状态不共享</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.of(&apos;foo&apos;, &apos;bar&apos;); //从一个值或多个值</span><br><span class="line">Rx.Observable.from([1, 2, 3]); //从数组</span><br><span class="line">Rx.Observable.fromEvent(document.querySelector(&apos;button&apos;), &apos;click&apos;); //从事件</span><br><span class="line">Rx.Observable.fromPromise(fetch(&apos;/users&apos;)); //从Promise</span><br><span class="line">Rx.Observable.bindCallback(fs.exists); //从回调函数</span><br><span class="line">Rx.Observable.create //- 自定义</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream$.subscribe(observer); //- 订阅-表示 Observable 的执行</span><br></pre></td></tr></table></figure>
<h3 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer - 观察者"></a>Observer - 观察者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var observer = &#123;</span><br><span class="line">    next: x =&gt; console.log(&apos;Got value: &apos;, x),</span><br><span class="line">    error: err =&gt; console.error(&apos;Error occurred: &apos;, err),</span><br><span class="line">    complete: () =&gt; console.log(&apos;Stream Done&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subscriber-对观察者的操作"><a href="#Subscriber-对观察者的操作" class="headerlink" title="Subscriber - 对观察者的操作"></a>Subscriber - 对观察者的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var subscriber = (observer) =&gt; &#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    observer.next(2);</span><br><span class="line">    observer.complete();</span><br><span class="line">    observer.error(&quot;Wrong Value&quot;);</span><br><span class="line"></span><br><span class="line">    return function unsubscribe() &#123;</span><br><span class="line">        console.log(&quot;observable clean&quot;);</span><br><span class="line">        clearInterval(interId);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subscription-观察者观察的控制-订阅对象-可清理资源的对象"><a href="#Subscription-观察者观察的控制-订阅对象-可清理资源的对象" class="headerlink" title="Subscription - 观察者观察的控制 - 订阅对象/可清理资源的对象"></a>Subscription - 观察者观察的控制 - 订阅对象/可清理资源的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var subsciption = observable.subscribe(observer);</span><br><span class="line">subsciption.unsubscribe();</span><br></pre></td></tr></table></figure>
<h3 id="Operator-操作符-重点"><a href="#Operator-操作符-重点" class="headerlink" title="Operator - 操作符 - 重点"></a>Operator - 操作符 - <em>重点</em></h3><ol>
<li><ol>
<li>操作符是 Observable 类型上的方法</li>
</ol>
</li>
<li><ol>
<li>当操作符被调用时，它们不会改变已经存在的 Observable 实例。相反，它们返回一个新的 Observable ，它的 subscription 逻辑基于第一个 Observable</li>
</ol>
</li>
<li><ol>
<li>操作符是纯函数 (pure function)，它基于当前的 Observable 创建一个新的 Observable。这是一个无副作用的操作：前面的 Observable 保持不变。</li>
</ol>
</li>
<li><ol>
<li>订阅输出 Observalbe 同样会订阅输入 Observable - 操作符订阅链</li>
</ol>
</li>
</ol>
<ul>
<li>创建操作符：from / range / of</li>
<li>多流操作符：combineLatest / concat / merge / zip</li>
<li>数学操作符：max / min / reduce</li>
<li>时间操作符：timer / take / delay / sampleTime / debounceTime / throttleTime</li>
<li>分组操作符：buffer / bufferTime / groupBy</li>
<li>异常处理： catch / retry / retryWhen</li>
</ul>
<p style="display:block;">更多代码详情看Demo Code</p>

<p style="display:block;">自定义操作符</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// - 创建自定义操作符</span><br><span class="line">// * 操作符应该永远返回一个 Observable</span><br><span class="line">// * 确保对你的操作符返回的 Observalbe 内部所创建的 subscriptions 进行管理</span><br><span class="line">// * 确保处理传入函数中的异常</span><br><span class="line">// * 确保在返回的 Observable 的取消订阅处理方法中释放稀缺资源</span><br><span class="line"></span><br><span class="line">// -&gt; 原理添加一个中间层代理，响应变化</span><br><span class="line">function mySimpleOperator(cb) &#123;</span><br><span class="line">    return Rx.Observable.create(subscriber =&gt; &#123;</span><br><span class="line">        var source = this;</span><br><span class="line"></span><br><span class="line">        var subsciption = source.subscribe(value =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                subscriber.next(cb(value));</span><br><span class="line">            &#125; catch (err) &#123;</span><br><span class="line">                subscriber.error(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, err =&gt; subscriber.error(err), () =&gt; subscriber.complete())</span><br><span class="line">        </span><br><span class="line">        return subsciption;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Subject-多播外部Observer"><a href="#Subject-多播外部Observer" class="headerlink" title="Subject - 多播外部Observer"></a>Subject - 多播外部Observer</h3><p style="display:block;"> (Observable –传值–&gt; Subject –multicast–&gt; Subscriber)</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var multicasted$ = Observable.multicast(Subject);</span><br><span class="line">multicasted$.connect();</span><br></pre></td></tr></table></figure>
<p style="display:block;">refCount - 通常，当第一个观察者到达时我们想要自动地连接，而当最后一个观察者取消订阅时我们想要自动地取消共享执行，产生引用计数refCount</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var refCountSource = Rx.Observable.interval(1000);</span><br><span class="line">var refCountSubject = new Rx.Subject();</span><br><span class="line"></span><br><span class="line">var refCounted = refCountSource.multicast(refCountSubject).refCount();</span><br><span class="line">var subScription1, subScription2;</span><br><span class="line"></span><br><span class="line">console.log(&quot;RefCountObs A Connect!&quot;);</span><br><span class="line">subScription1 = refCounted.subscribe(v =&gt; console.log(&quot;RefCountObs A:&quot;, v));</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;RefCountObs B Connect!&quot;);</span><br><span class="line">    subScription2 = refCounted.subscribe(v =&gt; console.log(&quot;RefCountObs B:&quot;, v));</span><br><span class="line">&#125;, 3000);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;RefCountObs A unsubscribed&apos;);</span><br><span class="line">    subScription1.unsubscribe();</span><br><span class="line">&#125;, 5000);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;RefCountObs B unsubscribed&apos;);</span><br><span class="line">    subScription2.unsubscribe();</span><br><span class="line">&#125;, 7000);</span><br></pre></td></tr></table></figure>
<h3 id="Scheduler-调度器"><a href="#Scheduler-调度器" class="headerlink" title="Scheduler - 调度器"></a>Scheduler - 调度器</h3><ul>
<li>调度器控制着何时启动 subscription 和何时发送通知。</li>
<li>调度器可以让你规定 Observable 在什么样的执行上下文中发送通知给它的观察者。</li>
<li>是一种数据结构, 是执行上下文, 有一个(虚拟的)时钟</li>
</ul>
<h3 id="编写弹珠测试-Marbles-Test"><a href="#编写弹珠测试-Marbles-Test" class="headerlink" title="编写弹珠测试 - Marbles Test"></a>编写弹珠测试 - Marbles Test</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var &#123; marbles &#125; = require(&apos;rxjs-marbles&apos;);</span><br><span class="line">var merge = require(&apos;rxjs&apos;).Observable.merge;</span><br><span class="line"></span><br><span class="line">// - 编写弹珠测试</span><br><span class="line">// - unit test func</span><br><span class="line">// - hot(marbles: string, values? : object, error? : any) - 已经在运行中的Observable - 可以使用&apos;^&apos;表示初始帧所在位置</span><br><span class="line">// - code(marbles, values, error) - 当测试开始时开始订阅</span><br><span class="line">// - expectObservable(actualObs).toBe(marbles, values, error) - 断言</span><br><span class="line">// - expectSubscription(actualSubscriptionLogs).toBe(subscriptionMarbles) - 订阅返回值的断言</span><br><span class="line"></span><br><span class="line">// Synatx</span><br><span class="line">// &apos;^&apos; -&gt; subscribe订阅点</span><br><span class="line">// &apos;-&apos; -&gt; 10帧</span><br><span class="line">// &apos;|&apos; -&gt; Observable.empty() // complete()</span><br><span class="line">// &apos;#&apos; -&gt; Observable.throw() // error()</span><br><span class="line">// &apos;a&apos; -? next(&apos;a&apos;)</span><br><span class="line">// &apos;(abc)&apos; -&gt; next(&apos;a&apos;) //—&gt; 多个事件同时发出值</span><br><span class="line"></span><br><span class="line">// &apos;!&apos; -&gt; 取消订阅时间点</span><br><span class="line"></span><br><span class="line">describe(&apos;Test&apos;, () =&gt; &#123;</span><br><span class="line">    it(&apos;demo1&apos;, marbles((m) =&gt; &#123;</span><br><span class="line">        var e1 = m.hot(&apos;--^--b-------c--|&apos;);</span><br><span class="line">        var e2 = m.hot( &apos;-^--e---------f----|&apos;);</span><br><span class="line">        var expected =   &apos;---(be)----c-f----|&apos;;</span><br><span class="line"></span><br><span class="line">        m.expect(e1.merge(e2)).toBeObservable(expected);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="应用的状态处理"><a href="#应用的状态处理" class="headerlink" title="应用的状态处理"></a>应用的状态处理</h3><p style="display:block;">应用的状态与存储</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var incre$ = Rx.Observable.fromEvent(document.querySelector(&quot;#app .incre&quot;), &quot;click&quot;)</span><br><span class="line">    .map(() =&gt; state =&gt; Object.assign(&#123;&#125;, state, &#123; count: state.count + 1 &#125;));</span><br><span class="line"></span><br><span class="line">var decre$ = Rx.Observable.fromEvent(document.querySelector(&quot;#app .decre&quot;), &quot;click&quot;)</span><br><span class="line">    .map(() =&gt; state =&gt; Object.assign(&#123;&#125;, state, &#123; count: state.count - 1 &#125;));</span><br><span class="line"></span><br><span class="line">var inputEnter$ = Rx.Observable.fromEvent(document.querySelector(&quot;input&quot;), &quot;keypress&quot;)</span><br><span class="line">    .map(ev =&gt; state =&gt; Object.assign(&#123;&#125;, state, &#123; inputVal: ev.target.value &#125;));</span><br><span class="line"></span><br><span class="line">var state$ = Rx.Observable.merge(incre$, decre$, inputEnter$) // - 合并状态</span><br><span class="line">    .scan((state, changeFn) =&gt; changeFn(state), &#123; count: 0, inputVal: &quot;&quot; &#125;);</span><br><span class="line"></span><br><span class="line">state$.subscribe(state =&gt; &#123;</span><br><span class="line">    document.querySelector(&quot;#app .state&quot;).innerHTML = state.inputVal + state.count;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Todo-List"><a href="#Todo-List" class="headerlink" title="Todo List"></a>Todo List</h3><ul>
<li>Auto Complete - 智能补全</li>
<li>Infinite Scroll - 无限滚动</li>
<li>Market Cart - 购物车案例</li>
</ul>
</div></article></div><footer class="footer"><p class="info">Welcome to mrzjd's blog!</p><div class="infobox"><ul class="contacts"><li class="contacts-i">QQ: 390303304</li><li class="contacts-i">Mail: 390303304@qq.com</li></ul><p>Powered by hexo and github. The theme is zebra-theme.</p></div></footer></body></html>
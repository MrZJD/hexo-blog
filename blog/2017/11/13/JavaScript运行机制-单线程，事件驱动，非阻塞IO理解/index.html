<!-- -> 定义页面布局--><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta name="keywords" content="Mrzjd Mrzebra hexo IT font-end 前端 技术"><meta name="keywords" content="Nodejs,JavaScript"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.8.0/github-markdown.min.css"><link rel="stylesheet" href="/blog/less/main.css"><link rel="icon" href="/blog/images/favicon.png"><title>JavaScript运行机制-单线程，事件驱动，非阻塞IO理解</title><script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="/blog/js/article.js"></script></head><body><header class="header"><h1 class="logo"><a href="/blog/" style="background-image:url(/blog//images/zblog-logo.png);">zblog</a></h1><i class="icon-list fa fa-bars"></i></header><div class="list-container"><ul class="header-list"><li class="header-item"><a href="/blog" title="HOME">HOME</a></li><li class="header-item"><a href="/blog/archives" title="Archives">Archives</a></li><li class="header-item"><a href="https://github.com/mrzjd" title="Github">Github</a></li></ul><div class="list-close"><i class="icon-close fa fa-times-circle-o"></i></div></div><div class="content"><article><div class="title-box"><h1 class="title"><span class="arti-tag" style="background:#43853d;">Nodejs</span>JavaScript运行机制-单线程，事件驱动，非阻塞IO理解</h1><div class="date"><i class="icon-calendar fa fa-calendar"></i><span class="time">2017.11.13</span></div></div><div class="article-text markdown-body"><h2 id="Nodejs-单线程？多线程？"><a href="#Nodejs-单线程？多线程？" class="headerlink" title="Nodejs-单线程？多线程？"></a>Nodejs-单线程？多线程？</h2><p>单线程</p>
<blockquote>
<p>总所周知，Nodejs一直以单线程，事件驱动，非阻塞IO标榜自己的并发处理。这也导致Nodejs在处理CPU密集任务时无法充分利用多核CPU的效率。<br><strong>但实际上，Nodejs的单线程指的是自身JavaScript运行环境的单线程，Nodejs在Javascript接口上并没有创建新线程的能力。</strong></p>
</blockquote>
<p>单线程的I/O如何处理？</p>
<blockquote>
<p>Nodejs中的IO为文件IO和网络IO（libuv实现）<br>filesystem, DNS操作 -&gt; 通过Thread Pool线程池实现<br>net.io -&gt; epoll, IOCP, kqueue来实现</p>
</blockquote>
<p>所以Nodejs底层内部是有多线程的处理的，那如何与Javascript通讯呢？ - 事件驱动</p>
<p><strong>重点-JavaScript异步模型</strong></p>
<blockquote>
<p>JavaScript Api -&gt; 调用异步方法，注册回调函数 -&gt; 封装成一个异步请求对象，将这个对象推入I/O线程池等待执行 -&gt; JavaScript 代码继续执行(非阻塞)<br>新线程或epoll等方式，执行IO操作 -&gt; I/O完成后 -&gt; 为请求对象添加result请求结果 -&gt; 添加进事件队列中 -&gt; 时间循环执行回调<br>底层平台(浏览器/Nodejs)维护这个I/O线程池，JavaScript代码没有创建新线程</p>
</blockquote>
<p><strong>事件循环：</strong></p>
<blockquote>
<p>在我们编写一个C程序求两个add的结果时，程序计算出来后输出结果，该进程就退出了。<br>那么在JavaScript中在此基础上再绑定一个IO事件，程序是不会在计算add结果后就退出。而是内部维护了一个事件队列，如果还有事件在pending状态则不断的循环，直到队列为空时程序退出。</p>
</blockquote>
<p>观察下面的程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;timer&apos;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">while(true) &#123;</span><br><span class="line">    // forever loop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，程序并不会打印’timer’。这是因为内部运行机制所导致的。</p>
<p><strong>重点-JavaScript运行机制</strong></p>
<blockquote>
<p>所有的同步任务(即js的代码部分)都是在主线程上执行的。<br>此外该线程上还维护了一个事件队列<br>当所有同步任务完成，系统就会读取事件队列中的内容<br>这称之为一个事件循环周期，直到事件队列中所有任务完成，没有事件在pending状态，主线程结束，退出程序。</p>
</blockquote>
<h2 id="梳理一下"><a href="#梳理一下" class="headerlink" title="梳理一下"></a>梳理一下</h2><p>根据上面的讨论，我们可以这样理解JavaScript的运行逻辑：</p>
<ol>
<li>main -&gt; 执行js代码，运行一系列操作(逻辑运算等)，绑定事件(DOM事件，异步操作等) -&gt; 这一步可以称之为执行栈</li>
<li>代码执行完毕 -&gt; 程序不会退出而是进入event loop检测事件状态，IO回调等</li>
<li>如果有事件触发/IO完成 -&gt; 将任务放进执行栈</li>
<li>重复上面3个阶段，直到没有IO和事件监听，程序才会退出</li>
</ol>
<h2 id="深入Event-loop"><a href="#深入Event-loop" class="headerlink" title="深入Event loop"></a>深入Event loop</h2><p>那事件循环的内部执行的逻辑究竟如何呢？(这里解释Nodejs下的事件循环)</p>
<ol>
<li>事件循环维护了一个队列，和一个time字段(初始化时为0，每次循环都会更新这个值)</li>
<li>a. -&gt; 更新time</li>
<li>-&gt; b.检测循环是否还有需要处理的任务, 没有则跳出循环结束程序, 有则进行下一步</li>
<li>-&gt; c.timer定时器中指定的时间与time字段比较, 如果timer&gt;time, 则执行该定时器</li>
<li>-&gt; d.I/O polling 阻塞住线程等待IO事件完成, 如果有事件完成，则放入执行栈中, 超出等待时间后，再次检查timer定时器的时间是否到期</li>
<li>-&gt; e.进入下一次循环</li>
</ol>
<p><strong>这个事件队列是有先后顺序的，先入列的先检测</strong></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><blockquote>
<p>进程是资源分配的基本单位。一个运行的任务即占有一个进程。<br>线程是CPU运行调度的基本单位。一个进程可以有多个线程。</p>
</blockquote>
<h3 id="多个定时器有没有性能问题？"><a href="#多个定时器有没有性能问题？" class="headerlink" title="多个定时器有没有性能问题？"></a>多个定时器有没有性能问题？</h3><p>根据我们事件循环的执行逻辑，多个定时器之间没有性能问题。但是多个定时器之间的任务逻辑需要准确把握。多个回调函数内部操作公共数据的逻辑需要清晰。</p>
<h3 id="浏览器中的setTimeout-setInterval-requestAnimationFrame的区别与联系"><a href="#浏览器中的setTimeout-setInterval-requestAnimationFrame的区别与联系" class="headerlink" title="浏览器中的setTimeout,setInterval,requestAnimationFrame的区别与联系"></a>浏览器中的setTimeout,setInterval,requestAnimationFrame的区别与联系</h3><p>我们通常使用setTimeout(fn, 0)来控制下一次事件循环开始时执行，此外HTML5规定间隔时间最短为4ms，从某种程度上来说这个时间间隔也并不可靠，它与当前执行栈的执行时间有关。<br>setInterval(fn, time)中的time表示执行间隔，但是当执行栈的耗时过长(程序阻塞时间过长)，是不能保证执行间隔的可靠性，所以一般通过setTimeout内部回调setTimeout来代替这种方式更符合逻辑。<br>我们知道浏览器的UI绘制每16ms执行一次，所以当我们使用setTimeout或者setInterval进行绘制动画时往往与JS代码阻塞情况有关。而requestAnimationFrame将动画执行逻辑交给了UI线程，由系统根据情况指定绘制时间间隔。</p>
<h3 id="Nodejs中的process-nextTick和setImmediate"><a href="#Nodejs中的process-nextTick和setImmediate" class="headerlink" title="Nodejs中的process.nextTick和setImmediate"></a>Nodejs中的process.nextTick和setImmediate</h3><p><strong>process.nextTick将回调放在eventloop之前执行，即任务栈的最后。内部递归调用自己，则程序永远不会执行eventloop</strong><br>setImmediate在官网文档中称它的回调在事件循环中执行顺序优先级高于setTimeout</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮一峰-JavaScript 运行机制详解：再谈Event Loop</a><br><a href="http://blog.csdn.net/xjtroddy/article/details/51388655" target="_blank" rel="noopener">单线程的 Node.js</a></p>
</div></article></div><footer class="footer"><p class="info">Welcome to mrzjd's blog!</p><div class="infobox"><ul class="contacts"><li class="contacts-i">QQ: 390303304</li><li class="contacts-i">Mail: 390303304@qq.com</li></ul><p>Powered by hexo and github. The theme is zebra-theme.</p></div></footer></body></html>
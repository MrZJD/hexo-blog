<!-- -> 定义页面布局--><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta name="keywords" content="Mrzjd Mrzebra hexo IT font-end 前端 技术"><meta name="keywords" content="Nodejs"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.8.0/github-markdown.min.css"><link rel="stylesheet" href="/blog/less/main.css"><link rel="icon" href="/blog/images/favicon.png"><title>Nodejs总结7之其他模块</title><script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="/blog/js/article.js"></script></head><body><header class="header"><h1 class="logo"><a href="/blog/" style="background-image:url(/blog//images/zblog-logo.png);">zblog</a></h1><i class="icon-list fa fa-bars"></i></header><div class="list-container"><ul class="header-list"><li class="header-item"><a href="/blog" title="HOME">HOME</a></li><li class="header-item"><a href="/blog/archives" title="Archives">Archives</a></li><li class="header-item"><a href="https://github.com/mrzjd" title="Github">Github</a></li></ul><div class="list-close"><i class="icon-close fa fa-times-circle-o"></i></div></div><div class="content"><article><div class="title-box"><h1 class="title"><span class="arti-tag" style="background:#43853d;">Nodejs</span>Nodejs总结7之其他模块</h1><div class="date"><i class="icon-calendar fa fa-calendar"></i><span class="time">2017.11.14</span></div></div><div class="article-text markdown-body"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前面我们学习了，Nodejs后台应用最基础的stream知识。利用stream我们可以处理网络IO，文件IO，process IO。利用这些基础的功能模块我们就可以开始进行Nodejs应用的编写了，但是在构建的过程中我们还有一些常用的工具库和变量等知识需要介绍。</p>
<h2 id="module模块加载系统"><a href="#module模块加载系统" class="headerlink" title="module模块加载系统"></a>module模块加载系统</h2><p>Nodejs - 采用CommonJS模块化规范标准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var moduleA = require(&apos;./moduleA.js&apos;); //引入</span><br><span class="line"></span><br><span class="line">module.exports = &#123;&#125;;//导出</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>模块在第一次加载后会被缓存，以后每次引入模块都会解析到同一个对象。(模块文件只会执行一次)</li>
<li>如果想要多次执行一个模块，可以导出一个函数，然后调用该函数。</li>
<li>当遇见循环引用时，系统会通过返回一个未完成的副本给循环引用的模块。</li>
</ul>
<h2 id="global全局变量"><a href="#global全局变量" class="headerlink" title="global全局变量"></a>global全局变量</h2><p><strong> __dirname </strong> 当前模块的文件夹名称<br><strong> __filename </strong> 当前模块的文件名称(绝对路径)<br><strong> module </strong><br><strong> exports </strong> -&gt; module.exports<br><strong> require() </strong></p>
<p><strong> Buffer </strong><br><strong> process </strong><br><strong> global </strong><br><strong> console </strong></p>
<p><strong> timer相关 </strong></p>
<h2 id="events-EventEmitter-类"><a href="#events-EventEmitter-类" class="headerlink" title="events - EventEmitter 类"></a>events - EventEmitter 类</h2><p>由事件驱动的Nodejs为我们也提供了自定义订阅者模式的events模块。（在设计模式一书中学习过该模式的实现，没有联系过的同学可以根据接口来实现一下，有助于理解订阅者模式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">const myEmitter = new EventEmitter();</span><br><span class="line"></span><br><span class="line">// 默认事件</span><br><span class="line">// &apos;newListener&apos; 事件 -&gt; 注册新事件时触发</span><br><span class="line">// &apos;removeListener&apos; 事件</span><br><span class="line"></span><br><span class="line">// emitter.addListener(eventName, listener)</span><br><span class="line">// emitter.emit(eventName[, ...args])</span><br><span class="line">// emitter.once(eventName, listener); //只触发一次的事件</span><br><span class="line">// emitter.prependListener(eventName, listener); //添加到该事件队列的顶端</span><br><span class="line">// emitter.prependOnceListener(eventName, listener)</span><br><span class="line"></span><br><span class="line">// emitter.removeListener(eventName, listener)</span><br><span class="line">// emitter.removeAllListeners([eventName])</span><br><span class="line"></span><br><span class="line">// emitter.eventNames(); //-&gt; 获取已注册的事件名称</span><br><span class="line">// emitter.setMaxListeners(n); / emitter.getMaxListeners()</span><br><span class="line">// emitter.listenerCount(eventName);</span><br><span class="line">// emitter.listeners(eventName)</span><br></pre></td></tr></table></figure>
<h2 id="path-系统路径"><a href="#path-系统路径" class="headerlink" title="path - 系统路径"></a>path - 系统路径</h2><p>我们知道在window和unix系统下，路径的表现有所不同。如win下通常’\\‘来表示文件夹的层叠，而unix下使用’/‘；win下使用’;’分割多文件路径，unix使用’:’。<br>为了是我们的代码不同平台下表现一直可以通过path来操作路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">path.delimiter; //多路径分隔符</span><br><span class="line"></span><br><span class="line">path.basename(path[, ext]); //获取path的最后一部分，文件夹或者文件</span><br><span class="line">path.dirname(path); //path所在的文件夹</span><br><span class="line">path.extname(path); //path的扩展名</span><br><span class="line">path.isAbsolute(path);</span><br><span class="line"></span><br><span class="line">path.join([...paths]); //**重点，使用对应的分隔符链接路径</span><br><span class="line">path.resolve([...paths]); //根据path和当前路径解析成一个绝对路径</span><br><span class="line"></span><br><span class="line">path.normalize(path); //规范化path解析</span><br><span class="line">path.parse(path); //string -&gt; obj</span><br><span class="line">path.format(pathObject); //obj -&gt; string</span><br><span class="line">path.relative(from, to); //获取相对路径</span><br><span class="line"></span><br><span class="line">path.win32/posix; //两种平台下的实现</span><br></pre></td></tr></table></figure>
<h2 id="querystring-处理查询字符串"><a href="#querystring-处理查询字符串" class="headerlink" title="querystring 处理查询字符串"></a>querystring 处理查询字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">querystring.stringify(obj[, sep[, eq[, options]]]); //将一个对象解析成query</span><br><span class="line">querystring.parse(str[, sep[, eq[, options]]]); //将一个字符串解析成obj</span><br><span class="line"></span><br><span class="line">// 默认都会进行encodeURIComponent/decodeURIComponent()</span><br></pre></td></tr></table></figure>
<h2 id="url-用于-URL-处理与解析"><a href="#url-用于-URL-处理与解析" class="headerlink" title="url 用于 URL 处理与解析"></a>url 用于 URL 处理与解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var url = new URL(input[, base]);</span><br><span class="line"></span><br><span class="line">// url.href = https://user:pass@baidu.com:8000/pathname?searchquery#hash</span><br><span class="line"></span><br><span class="line">// url.protocol/url.username/.password</span><br><span class="line">// url.host/.origin/.hostname/.port -&gt; hostname不包括端口号</span><br><span class="line">// url.pathname</span><br><span class="line">// url.search/url.searchParams</span><br><span class="line">// url.hash</span><br><span class="line"></span><br><span class="line">// URLSearchParams 类-操作url query</span><br><span class="line">// ?/abc=123</span><br><span class="line">// url.searchParams.get(&apos;abc&apos;); //获取</span><br><span class="line">// url.searchParams.append(&apos;abc&apos;, &apos;xyz&apos;); //添加</span><br><span class="line">// url.searchParams.delete(&apos;abc&apos;); //删除</span><br><span class="line">// url.searchParams.set(&apos;a&apos;, &apos;b&apos;); //新增</span><br><span class="line">// .toString()</span><br><span class="line">// .has(name)</span><br><span class="line">// .keys() / .entries() / .forEach(fn[, thisArg])</span><br></pre></td></tr></table></figure>
<h2 id="string-decoder-字符串解码器"><a href="#string-decoder-字符串解码器" class="headerlink" title="string_decoder 字符串解码器"></a>string_decoder 字符串解码器</h2><p>用于把 Buffer 对象解码成字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const decoder = new StringDecoder(&apos;utf8&apos;)</span><br><span class="line">stringDecoder.write(buffer);</span><br><span class="line">stringDecoder.end([buffer]);</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="http://nodejs.cn/api/cluster.html#cluster_cluster" target="_blank" rel="noopener">cluster</a> - 用于集群处理(多个Nodejs进程)</li>
<li><a href="http://nodejs.cn/api/dgram.html#dgram_udp_datagram_sockets" target="_blank" rel="noopener">dgram</a> - udp处理</li>
<li><a href="http://nodejs.cn/api/dns.html#dns_dns" target="_blank" rel="noopener">dns</a> - 处理dns相关</li>
<li><a href="http://nodejs.cn/api/errors.html#errors_errors" target="_blank" rel="noopener">error</a> - 了解相关错误异常相关信息</li>
<li><a href="http://nodejs.cn/api/zlib.html#zlib_zlib" target="_blank" rel="noopener">zlib</a> - 压缩/解压缩数据</li>
<li><a href="http://nodejs.cn/api/util.html#util_util" target="_blank" rel="noopener">util</a> - 工具库-提供了promise/callback的相关转换，inherits等函数</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://segmentfault.com/a/1190000004873947" target="_blank" rel="noopener">AMD, CMD, CommonJS和UMD</a></li>
<li><a href="http://nodejs.cn/api/globals.html#globals_global_objects" target="_blank" rel="noopener">nodejs - global - 全局变量</a></li>
<li><a href="http://nodejs.cn/api/events.html#events_events" target="_blank" rel="noopener">nodejs - events (事件)</a></li>
</ul>
</div></article></div><footer class="footer"><p class="info">Welcome to mrzjd's blog!</p><div class="infobox"><ul class="contacts"><li class="contacts-i">QQ: 390303304</li><li class="contacts-i">Mail: 390303304@qq.com</li></ul><p>Powered by hexo and github. The theme is zebra-theme.</p></div></footer></body></html>
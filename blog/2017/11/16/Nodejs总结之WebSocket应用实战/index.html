<!-- -> 定义页面布局--><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta name="keywords" content="Mrzjd Mrzebra hexo IT font-end 前端 技术"><meta name="keywords" content="Nodejs"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.8.0/github-markdown.min.css"><link rel="stylesheet" href="/blog/less/main.css"><link rel="icon" href="/blog/images/favicon.png"><title>Nodejs总结之WebSocket应用实战</title><script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="/blog/js/article.js"></script></head><body><header class="header"><h1 class="logo"><a href="/blog/" style="background-image:url(/blog//images/zblog-logo.png);">zblog</a></h1><i class="icon-list fa fa-bars"></i></header><div class="list-container"><ul class="header-list"><li class="header-item"><a href="/blog" title="HOME">HOME</a></li><li class="header-item"><a href="/blog/archives" title="Archives">Archives</a></li><li class="header-item"><a href="https://github.com/mrzjd" title="Github">Github</a></li></ul><div class="list-close"><i class="icon-close fa fa-times-circle-o"></i></div></div><div class="content"><article><div class="title-box"><h1 class="title"><span class="arti-tag" style="background:#43853d;">WebSocket</span>Nodejs总结之WebSocket应用实战</h1><div class="date"><i class="icon-calendar fa fa-calendar"></i><span class="time">2017.11.16</span></div></div><div class="article-text markdown-body"><h2 id="Talk-is-Cheap-Show-me-the-code"><a href="#Talk-is-Cheap-Show-me-the-code" class="headerlink" title="Talk is Cheap, Show me the code!"></a>Talk is Cheap, Show me the code!</h2><p><a href="/demo/node-knowledge/chatroom.zip">WebSocket-Nodejs无依赖实现-代码压缩包</a></p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>我们知道浏览器WWW的主要协议为http/https协议，而http协议是无状态的。在一次请求中数据传输只有一次。所有当我们需要处理实时性的需求时，通常会有一些hack方案: 如ajax polling轮询; http 长连接; 这些方案虽然都可以完成需求，但是处理起来不仅复杂而且浪费了许多不必要的网络资源等。</p>
<p>在HTML5规范中，为开发者提供了WebSocket方案。WebSocket是利用了HTTP的请求方案，基于TCP与服务器建立联系；利用相关接口Web开发将可以建立稳定可靠的双向通讯接口。</p>
<p>下面我们将讲解WebSocket的实现原理，然后从Web Browser端和Nodejs Server端具体讲解WebSocket的实现。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>1. 基于HTTP</strong></p>
<blockquote>
<p>a. 当我们需要一个websocket连接时，我们需要向服务器发送一个HTTP请求 -&gt; 建立tcp连接 -&gt; 通过HTTP报文: 告诉服务器我需要的是一个WebSocket而不是HTTP Response.<br>b. 服务器解析报文信息后: 告诉客户端 -&gt; 好的，可以给一个WebSocket连接你。<br>c. 这样我们就建立一个基于tcp的连接<br><strong>注意：HTTP只是建立WebSocket时所使用的渠道，后续的数据传输工作都是基于tcp的</strong></p>
</blockquote>
<p><strong>2. WebSocket数据报文</strong></p>
<blockquote>
<p>a. 建立好了一个WebSocket连接，下面我们要开始传输数据了。<br>b. 大家都知道tcp是基于字节流的传输层协议<br>c. 那么这些字节流数据就需要一定的格式约束 -&gt; WebSocket报文格式<br>d. 这些格式指示了解析数据的方式 -&gt; 是否一次数据传输完成。这一次数据的数据量有多少。需不需要掩码等</p>
</blockquote>
<h2 id="WebSocket-in-Server-Nodejs-报文解析"><a href="#WebSocket-in-Server-Nodejs-报文解析" class="headerlink" title="WebSocket in Server(Nodejs) 报文解析"></a>WebSocket in Server(Nodejs) 报文解析</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 客户端发送一段数据 data = &apos;123&apos;</span><br><span class="line">// 请求报文为 -&gt;</span><br><span class="line">// baowen = &lt;Buffer 81 83 1c aa cd 3f 6d dd a8&gt;</span><br></pre></td></tr></table></figure>
<p>这一段数据的组成部分如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 第一个字节</span><br><span class="line">// baowen[0] = 0x81;</span><br><span class="line">// baowen[0].toString(2); // -&gt; 转为二进制</span><br><span class="line">// &apos;1 0 0 0 0 0 0 1&apos;</span><br><span class="line"></span><br><span class="line">// -&gt; 取第一个bit -&gt; 描述消息是否结束</span><br><span class="line">// -&gt; 1为消息结束 -&gt; 0还有后续数据包</span><br><span class="line">var bit1 = baowen[0] &gt;&gt; 7;</span><br><span class="line"></span><br><span class="line">// -&gt; 取5-8bit -&gt; 消息类型</span><br><span class="line">// -&gt; 1为数据包 -&gt; 8为请求close断开连接</span><br><span class="line">var bit5_8 = baowen[0] &amp; 0xF;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第二个字节 -&gt; 描述掩码和消息长度</span><br><span class="line">// baowen[1] = 0x83;</span><br><span class="line"></span><br><span class="line">// 取最高位bit -&gt; 是否有掩码</span><br><span class="line">// 1 -&gt; 有</span><br><span class="line">var hasMask = (baowen[1] &gt;&gt;7);</span><br><span class="line"></span><br><span class="line">// 后面7位用来描述消息长度</span><br><span class="line">var lenFlag = baowen[1] &amp; 0x7F;</span><br><span class="line"></span><br><span class="line">// 当数据包小于126时 -&gt; lenFlag为实际数据包长度</span><br><span class="line">// 当数据包长度小于uint16时 -&gt; lenFlag=126;</span><br><span class="line">// 当数据包大于uint16时 -&gt; lenFlag=127;</span><br></pre></td></tr></table></figure>
<p>如果数据长度大于126小于uint16时 -&gt; 接下来的两个字节表示数据包长度;<br>如果数据长度小于uint16 -&gt; 接下来的四个字节表示数据包长度;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var nowi = 2;</span><br><span class="line">if (lenFlag === 126) &#123;</span><br><span class="line">    pkgLength = Buffer.from(data.slice(2, 4)).readUInt16BE();</span><br><span class="line">    nowi += 2;</span><br><span class="line">&#125; else if (lenFlag === 127) &#123;</span><br><span class="line">    pkgLength = Buffer.from(data.slice(2, 6)).readUInt32BE();</span><br><span class="line">    nowi += 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果hasMask为1 -&gt; 有掩码 -&gt; 取接下来的4个字节为掩码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (hasMask) &#123;</span><br><span class="line">    maskCode = Buffer.from(baowen.slice(nowi, nowi+4));</span><br><span class="line">    nowi += 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来的字节 -&gt; 消息体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 如果有掩码 -&gt; 解码规则为1-4byte掩码循环和数据byte做异或操作</span><br><span class="line">var result = Buffer.from(data.slice(nowi));</span><br><span class="line">if (!!maskCode) &#123;</span><br><span class="line">    for(var i=0, len=result.length;i &lt; len; i++) &#123;</span><br><span class="line">        result[i] = result[i] ^ maskCode[i%4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们得到了我们需要的数据体 - result&lt;buffer&gt;</p>
<p>至此我们完成了客户端发来的数据报的解析</p>
<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>我们不仅要读懂用户发来的数据，我们向用户发送的数据也需要用户可以看懂。所以需要对原始数据格式化后发送给客户端。</p>
<p>这一部分相对简单。</p>
<p><strong>以0x81开头，紧接发送内容的长度，最后是消息体;</strong></p>
<p><strong>注意这里的内容长度格式，依然需要遵守我们解析时的规则</strong></p>
<h2 id="WebSocket-Server"><a href="#WebSocket-Server" class="headerlink" title="WebSocket Server"></a>WebSocket Server</h2><p>看懂了报文，我们就拥有处理请求的能力了。接下来我们讲解如何与客户端握手成功(建立连接)，然后我们才能获取到报文数据，利用上面的知识与客户端通信。</p>
<p><strong>1. 由于WebSocket是通过HTTP来建立基于tcp的链接 -&gt; 创建http服务器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// -&gt; 这里只处理websocket请求的情况</span><br><span class="line">var socketServer = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">    const body = http.STATUS_CODES[426];</span><br><span class="line">    // 426 Upgrade Required -&gt; 表示需要将当前协议进行转换</span><br><span class="line"></span><br><span class="line">    res.writeHead(426, &#123;</span><br><span class="line">        &apos;Content-Length&apos;: body.length,</span><br><span class="line">        &apos;Content-Type&apos;: &apos;text/plain&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.send(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>2. HTTP -&gt; WebSocket 协议升级</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// -&gt; 接下来通过upgrade事件向websocket协议转换</span><br><span class="line">socketServer.on(&apos;upgrade&apos;, (req, socket, head) =&gt; &#123;</span><br><span class="line">    // 根据请求报文验证websocket信息</span><br><span class="line"></span><br><span class="line">    // 1. websocket版本号</span><br><span class="line">    const version = +req.headers[&apos;sec-websocket-version&apos;];</span><br><span class="line"></span><br><span class="line">    // 2. websocket验证</span><br><span class="line">    if (req.method !== &apos;GET&apos; || req.headers.upgrade.toLowerCase() !== &apos;websocket&apos; || !req.headers[&apos;sec-websocket-key&apos;] || (version !== 8 &amp;&amp; version !== 13)) &#123;</span><br><span class="line">        // -&gt; 如果upgrade信息错误则返回</span><br><span class="line">        return abortReqeust(socket, 400);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 生成响应信息头</span><br><span class="line"></span><br><span class="line">    // 3. 根据客户端提供的key值生成verify确认值</span><br><span class="line">    const key = crypto.createHash(&apos;sha1&apos;)</span><br><span class="line">        .update(req.headers[&apos;sec-websocket-key&apos;] + &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;, &apos;binary&apos;)</span><br><span class="line">        .digest(&apos;base64&apos;);</span><br><span class="line">    </span><br><span class="line">    const headers = [</span><br><span class="line">        &apos;HTTP/1.1 101 Switching Protocols&apos;,</span><br><span class="line">        &apos;Upgrade: websocket&apos;,</span><br><span class="line">        &apos;Connection: Upgrade&apos;,</span><br><span class="line">        `Sec-WebSocket-Accept: $&#123;key&#125;`</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    var protocol = (req.headers[&apos;sec-websocket-protocol&apos;] || &apos;&apos;).split(/, */);</span><br><span class="line">    if (protocol[0]) &#123;</span><br><span class="line">        headers.push(`Sec-WebSocket-Protocol: $&#123;protocol[0]&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // if (req.headers[&apos;sec-websocket-extensions&apos;]) &#123;</span><br><span class="line">    //     headers.push(`Sec-WebSocket-Extensions: $&#123;req.headers[&apos;sec-websocket-extensions&apos;]&#125;`);</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    socket.write(headers.concat(&apos;&apos;, &apos;&apos;).join(&apos;\r\n&apos;));</span><br><span class="line"></span><br><span class="line">    // 创建完成</span><br><span class="line">    // 通过MyClient维护socket数据流;</span><br><span class="line">    const client = new MyClient([socket, head]）；</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>3. 维护socket池</strong></p>
<p>这一部分具体请查看 - nodejs - net.Socket类</p>
<ul>
<li><a href="http://nodejs.cn/api/net.html#net_class_net_socket" target="_blank" rel="noopener">nodejs - net.Socket类</a></li>
<li><a href="/blog/2017/11/10/Nodejs总结2-网络处理http-net/">Nodejs总结2-网络处理http/net</a></li>
</ul>
<h2 id="WebSocket-in-Browser"><a href="#WebSocket-in-Browser" class="headerlink" title="WebSocket in Browser"></a>WebSocket in Browser</h2><p>浏览器端的WebSocket开发相对而言就要简单很多了，因为我们不需要去处理报文的解析和编码;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var websocket = new WebSocket(url);</span><br><span class="line">        </span><br><span class="line">websocket.onopen = open;</span><br><span class="line">websocket.onmessage = msg;</span><br><span class="line">websocket.onclose = close;</span><br><span class="line">websocket.onerror = err;</span><br><span class="line"></span><br><span class="line">websocket.send(msg);</span><br><span class="line">websocket.close();</span><br></pre></td></tr></table></figure>
<p><strong>这里需要注意的是，close并不是直接关闭连接，而是向服务器发送一条请求关闭的报文。</strong></p>
<p>至此我们完成一个，比较完整的WebSocket服务构建。</p>
<h2 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h2><p>我们学习这些底层通讯协议的知识，是为了了解websocket的应用流程。更好的处理关联相关应用场景；但是个人的维护起这些底层的东西往往是不全面的，以及兼容性不好。这里推荐大家使用socket.io/ws库。</p>
<blockquote>
<p>由于浏览器端对HTML5的支持不一，为了兼容所有浏览器，提供卓越的实时的用户体验，并且为程序员提供客户端与服务端一致的编程体验，于是socket.io诞生。Socket.io将Websocket和轮询 （Polling）机制以及其它的实时通信方式封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。</p>
</blockquote>
<p>Socket.io都实现的通信机制：</p>
<ul>
<li>Adobe® Flash® Socket</li>
<li>AJAX long polling</li>
<li>AJAX multipart streaming</li>
<li>Forever Iframe</li>
<li>JSONP Polling</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍WebSocket相关的知识，其他运用的知识点：HTTP Upgrade进行协议升级，WebSocket协议相关的数据头和报文解析，以及Socket的维护。<br>在日常应用的开发中我们可以使用socket.io库来实现实时通讯技术的应用需求。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/websockets/ws" target="_blank" rel="noopener">Github - /websock/ws</a></li>
<li><a href="https://github.com/socketio/socket.io/" target="_blank" rel="noopener">Github - /socketio/socket.io/</a></li>
<li><a href="https://socket.io/" target="_blank" rel="noopener">socket.io - 官方文档</a></li>
<li><a href="https://cnodejs.org/topic/50a1fcc7637ffa4155b5a264" target="_blank" rel="noopener">cnode - socket.io入门整理</a><br><br></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">MSN - WebSocket</a></li>
<li><a href="https://www.cnblogs.com/smark/archive/2012/11/26/2789812.html" target="_blank" rel="noopener">cnblogs - WebSocket数据包协议详解</a></li>
<li><a href="http://www.voidcn.com/article/p-sdgtzxzy-cc.html" target="_blank" rel="noopener">WebSocket协议详解</a><br><br></li>
<li><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">知乎 - WebSocket 是什么原理？为什么可以实现持久连接？</a></li>
</ul>
</div></article></div><footer class="footer"><p class="info">Welcome to mrzjd's blog!</p><div class="infobox"><ul class="contacts"><li class="contacts-i">QQ: 390303304</li><li class="contacts-i">Mail: 390303304@qq.com</li></ul><p>Powered by hexo and github. The theme is zebra-theme.</p></div></footer></body></html>
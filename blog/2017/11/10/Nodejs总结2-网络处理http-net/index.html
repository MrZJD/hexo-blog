<!-- -> 定义页面布局--><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta name="keywords" content="Mrzjd Mrzebra hexo IT font-end 前端 技术"><meta name="keywords" content="Nodejs"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.8.0/github-markdown.min.css"><link rel="stylesheet" href="/blog/less/main.css"><link rel="icon" href="/blog/images/favicon.png"><title>Nodejs总结2-网络处理http/net</title><script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="/blog/js/article.js"></script></head><body><header class="header"><h1 class="logo"><a href="/blog/" style="background-image:url(/blog//images/zblog-logo.png);">zblog</a></h1><i class="icon-list fa fa-bars"></i></header><div class="list-container"><ul class="header-list"><li class="header-item"><a href="/blog" title="HOME">HOME</a></li><li class="header-item"><a href="/blog/archives" title="Archives">Archives</a></li><li class="header-item"><a href="https://github.com/mrzjd" title="Github">Github</a></li></ul><div class="list-close"><i class="icon-close fa fa-times-circle-o"></i></div></div><div class="content"><article><div class="title-box"><h1 class="title"><span class="arti-tag" style="background:#43853d;">Nodejs</span>Nodejs总结2-网络处理http/net</h1><div class="date"><i class="icon-calendar fa fa-calendar"></i><span class="time">2017.11.10</span></div></div><div class="article-text markdown-body"><h2 id="Nodejs网络处理"><a href="#Nodejs网络处理" class="headerlink" title="Nodejs网络处理"></a>Nodejs网络处理</h2><p>Nodejs与其他平台无异，都提供了丰富的网络处理接口。</p>
<p>分为以下两个内容介绍:</p>
<blockquote>
<p>http/https模块提供了处理相关协议的服务器和客户端接口<br>net模块提供 TCP/IPC 服务器和客户端的网络接口</p>
</blockquote>
<h2 id="http-Agent-类-中间者，代理http的客户端请求"><a href="#http-Agent-类-中间者，代理http的客户端请求" class="headerlink" title="http.Agent 类 - (中间者，代理http的客户端请求)"></a>http.Agent 类 - (中间者，代理http的客户端请求)</h2><blockquote>
<p>负责客户端HTTP管理连接的持续和复用(创建一个单一Socket，一个等待请求的队列)<br>即一个Agent可以重复发送请求，可以指定内部Socket的相关配置(如keepAlive等)，如果不再需要这个客户端发送请求，需要手动 <em>agent.destory()</em>;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent.createConnection(opts, callback); // 创建一个请求socket/流</span><br></pre></td></tr></table></figure>
<h2 id="http-ClientRequest-类"><a href="#http-ClientRequest-类" class="headerlink" title="http.ClientRequest 类"></a>http.ClientRequest 类</h2><blockquote>
<p>通过 <strong>http.get() / http.request()</strong> 方法内部创建并返回，表示一个正在处理的请求。实现了可写流接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var request = http.get(opts);</span><br><span class="line"></span><br><span class="line">// Events: &apos;abort&apos;, &apos;connect&apos;, &apos;continue&apos;, &apos;response&apos;, &apos;socket&apos;, &apos;timeout&apos;, &apos;upgrade&apos;</span><br><span class="line"></span><br><span class="line">// 常用方法:</span><br><span class="line">// request.setHeader(&apos;key&apos;, &apos;val&apos;/[val, val2]);</span><br><span class="line">// request.removeHeader(&apos;key); / request.getHeader(&apos;key&apos;);</span><br><span class="line">// request.write(chunk); //发送请求主体</span><br><span class="line">// request.end()</span><br><span class="line">// request.abort()</span><br><span class="line">// request.setTimeout()</span><br></pre></td></tr></table></figure>
<h2 id="http-Server-类-extends-net-Server"><a href="#http-Server-类-extends-net-Server" class="headerlink" title="http.Server 类 extends net.Server"></a>http.Server 类 extends net.Server</h2><blockquote>
<p>通过http.createServer创建并返回</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var server = http.createServer( (req, res) =&gt; &#123;&#125; );</span><br><span class="line"></span><br><span class="line">// Events:</span><br><span class="line">// &apos;clientError&apos; 客户端触发error事件时触发，监听器需要负责关闭和销毁socket</span><br><span class="line">// &apos;request&apos; 每次接受到一个请求时触发</span><br><span class="line">// &apos;close&apos;, &apos;connect&apos;, &apos;connection&apos;, &apos;upgrade&apos;</span><br><span class="line"></span><br><span class="line">// Functions: close(), listen(), setTimeout()</span><br></pre></td></tr></table></figure>
<p><em>createServer方法会将监听器自动绑定到request事件上</em></p>
<h2 id="http-ServerResponse-类"><a href="#http-ServerResponse-类" class="headerlink" title="http.ServerResponse 类"></a>http.ServerResponse 类</h2><blockquote>
<p>实现了可写流接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var reqListener = (req, res) =&gt; &#123;</span><br><span class="line">    // res -&gt; 即ServerResponse对象</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Events: &apos;close&apos;, &apos;finish&apos;</span><br><span class="line"></span><br><span class="line">// Functions:</span><br><span class="line">// res.setHeader(key, val);</span><br><span class="line">// res.getHeaders()</span><br><span class="line">// res.getHeader(key)</span><br><span class="line">// res.getHeaderNames()</span><br><span class="line">// res.hasHeader(key)</span><br><span class="line">// res.removeHeader(key)</span><br><span class="line"></span><br><span class="line">// res.writeHeader(statusCode, statusMessage, headers)</span><br><span class="line">// -&gt; 对应到res.statusCode, res.statusMessage</span><br><span class="line">// res.write(chunk);</span><br></pre></td></tr></table></figure>
<h2 id="http-IncomingMessage-类"><a href="#http-IncomingMessage-类" class="headerlink" title="http.IncomingMessage 类"></a>http.IncomingMessage 类</h2><blockquote>
<p>实现了可读流<br>在http.Server中作为监听器的req参数对象<br>在http.ClientRequest中作为response参数对象<br>实际就是表示来源数据的对象，在服务器中是客户端发过来的请求数据，在客户端中是服务器的响应数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var incomingMsg;</span><br><span class="line"></span><br><span class="line">// Events: &apos;aborted&apos;, &apos;close&apos;</span><br><span class="line"></span><br><span class="line">// Props:</span><br><span class="line">// msg.headers //-&gt; http数据头</span><br><span class="line">// msg.method</span><br><span class="line">// msg.rawHeaders</span><br><span class="line">// msg.statusCode</span><br><span class="line">// msg.statusMessage</span><br><span class="line">// msg.url</span><br><span class="line"></span><br><span class="line">// Function: msg.destroy()</span><br></pre></td></tr></table></figure>
<h2 id="net-Server-类"><a href="#net-Server-类" class="headerlink" title="net.Server 类"></a>net.Server 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var server = new net.Server(opts, listener); // listener -&gt; &apos;connection&apos;</span><br><span class="line"></span><br><span class="line">// Events: &apos;close&apos;, &apos;connection&apos;, &apos;error&apos;, &apos;listening&apos;</span><br><span class="line"></span><br><span class="line">// Functions:</span><br><span class="line">// server.address();</span><br><span class="line">// server.close();</span><br><span class="line">// server.getConnections(cb) //=&gt; 异步获取当前并发数</span><br><span class="line">// server.listen();</span><br><span class="line"></span><br><span class="line">// listen方法参数的类型不同也决定其创建的服务器类型的不同</span><br><span class="line">// server.listen([port][, host][, backlog][, callback]) -&gt; tcp</span><br><span class="line">// server.listen(path[, backlog][, callback]) -&gt; ipc</span><br><span class="line">// server.listen(options[, callback]) -&gt; 根据option来判断类型</span><br></pre></td></tr></table></figure>
<h2 id="net-Socket-类"><a href="#net-Socket-类" class="headerlink" title="net.Socket 类"></a>net.Socket 类</h2><p>实现了Duplex可读可写流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Events: &apos;close&apos;, &apos;connect&apos;, &apos;data&apos;, &apos;drain&apos;, &apos;end&apos;, &apos;error&apos;, &apos;lookup&apos;, &apos;timeout&apos;</span><br><span class="line"></span><br><span class="line">// Functions:</span><br><span class="line">// socket.connect(options[, connectListener])</span><br><span class="line">// socket.connect(port[, host][, connectListener]) //-&gt; tcp</span><br><span class="line">// socket.connect(path[, connectListener]) //-&gt; ipc</span><br><span class="line"></span><br><span class="line">// socket.destory()</span><br><span class="line">// socket.end()</span><br><span class="line">// socket.write()</span><br><span class="line">// socket.setTimeout()</span><br><span class="line">// socket.setEncoding()</span><br><span class="line">// socket.resume()</span><br><span class="line">// socket.pause()</span><br><span class="line"></span><br><span class="line">// socket.localPort/localAddress/remotePort/remoteAddress</span><br></pre></td></tr></table></figure>
<h2 id="net-全局函数"><a href="#net-全局函数" class="headerlink" title="net 全局函数"></a>net 全局函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">net.createConnection() //=&gt; 创建net.socket的工厂函数</span><br><span class="line">// -&gt; 同样拥有多种参数模式</span><br><span class="line">// net.createConnection(options[, connectListener])</span><br><span class="line">// net.createConnection(port[, host][, connectListener])</span><br><span class="line">// net.createConnection(path[, connectListener])</span><br><span class="line"></span><br><span class="line">net.connect() //=&gt; 同createConnetion</span><br><span class="line"></span><br><span class="line">net.createServer([options][, connectionListener]) //=&gt; 创建net.Server的工厂</span><br><span class="line"></span><br><span class="line">// other</span><br><span class="line">// net.isIP()</span><br><span class="line">// net.isIPv4/isIPv6()</span><br></pre></td></tr></table></figure>
<h2 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h2><ul>
<li>利用http搭建静态服务器</li>
<li>利用http建立类似koa/express的服务器路由处理</li>
<li>编写http-body-parser完成服务器对post数据的解析</li>
<li>爬虫练习</li>
</ul>
<ul>
<li>利用net tcp服务器创建websocket聊天室</li>
</ul>
<h2 id="附录链接："><a href="#附录链接：" class="headerlink" title="附录链接："></a>附录链接：</h2><ul>
<li><a href="http://nodejs.cn/api/http.html#http_http" target="_blank" rel="noopener">nodejs - http</a></li>
<li><a href="http://nodejs.cn/api/net.html#net_net" target="_blank" rel="noopener">nodejs - net</a></li>
</ul>
</div></article></div><footer class="footer"><p class="info">Welcome to mrzjd's blog!</p><div class="infobox"><ul class="contacts"><li class="contacts-i">QQ: 390303304</li><li class="contacts-i">Mail: 390303304@qq.com</li></ul><p>Powered by hexo and github. The theme is zebra-theme.</p></div></footer></body></html>
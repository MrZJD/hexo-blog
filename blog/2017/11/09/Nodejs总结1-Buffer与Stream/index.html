<!-- -> 定义页面布局--><!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta name="keywords" content="Mrzjd Mrzebra hexo IT font-end 前端 技术"><meta name="keywords" content="Nodejs"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/github-markdown-css/2.8.0/github-markdown.min.css"><link rel="stylesheet" href="/blog/less/main.css"><link rel="icon" href="/blog/images/favicon.png"><title>Nodejs总结1-Buffer与Stream</title><script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="/blog/js/article.js"></script></head><body><header class="header"><h1 class="logo"><a href="/blog/" style="background-image:url(/blog//images/zblog-logo.png);">zblog</a></h1><i class="icon-list fa fa-bars"></i></header><div class="list-container"><ul class="header-list"><li class="header-item"><a href="/blog" title="HOME">HOME</a></li><li class="header-item"><a href="/blog/archives" title="Archives">Archives</a></li><li class="header-item"><a href="https://github.com/mrzjd" title="Github">Github</a></li></ul><div class="list-close"><i class="icon-close fa fa-times-circle-o"></i></div></div><div class="content"><article><div class="title-box"><h1 class="title"><span class="arti-tag" style="background:#43853d;">Nodejs</span>Nodejs总结1-Buffer与Stream</h1><div class="date"><i class="icon-calendar fa fa-calendar"></i><span class="time">2017.11.09</span></div></div><div class="article-text markdown-body"><h2 id="什么是Buffer和Stream"><a href="#什么是Buffer和Stream" class="headerlink" title="什么是Buffer和Stream"></a>什么是Buffer和Stream</h2><blockquote>
<p>Buffer是用于管理和操作存放二进制数据的<strong>缓存区</strong>的类型 (Buffer中的数据形式为Uint8Array)<br>Stream是处理流数据的抽象接口 (流是一组有序的、有起点和终点的字节数据的传输手段)</p>
</blockquote>
<p>Stream将数据存储到内部缓存Buffer中，流的消费者通过接口读取数据。这种形式提供了操作大量数据时的行为方式：读取文件-&gt;文件数据分割chunk-&gt;推入一部分到内存中-&gt;消费者读取一部分数据</p>
<p>ex. 处理这样一个需求：前端上传一个文件保存到文件系统中。<br>没有Stream我们这样处理: <strong>client -&gt; upload file -&gt; chunk += chunk(等待数据网络传输全部完成) -&gt; opt(data)(数据操作) -&gt; save file</strong>。<br>而通过Stream: <strong>client -&gt; upload file -&gt; save( opt(chunk) )</strong>。</p>
<p>如果在数据量非常大的情况下，第一种方式所消耗的内存非常的大，而且等待数据io/写入一个大文件io都非常的耗时；相比较通过Stream，当网络返回一个数据包chunk时就通过流放入缓存中，同时通过消费者(写入文件)及时消费，不仅节约内存而且耗时也会减少许多。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在Nodejs中，只要是与数据IO相关的处理多少都需要用到流。如HTTP服务器处理req, res; FileSystem的读写操作等; 这里介绍流的使用范式。</p>
<p>Stream的类型：可写流Writable，可读流Readable，可读可写流Duplex，变换流Transform</p>
<h2 id="可写流-stream-Writable-类"><a href="#可写流-stream-Writable-类" class="headerlink" title="可写流(stream.Writable 类)"></a>可写流(stream.Writable 类)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var writerStream = WriterStream(); //假设writer为一个可写流</span><br><span class="line"></span><br><span class="line">writerStream.write(&apos;data1&apos;);</span><br><span class="line">writerStream.write(&apos;data2&apos;);</span><br><span class="line">writerStream.end(&apos;end data&apos;);</span><br><span class="line"></span><br><span class="line">// Event: &apos;finish&apos;, &apos;error&apos;, &apos;drain&apos;, &apos;pipe&apos;, &apos;close&apos;, &apos;unpipe&apos;</span><br><span class="line"></span><br><span class="line">// 这里主要说明drain情况</span><br><span class="line">// Stream中highWaterMark将决定缓存的大小(总字节数)</span><br><span class="line">// 当缓存中的数据到达阈值时，push/write将不再生效，直到缓存的数据被消费</span><br><span class="line"></span><br><span class="line">// drain事件就是可写流缓存数据过大，暂停缓存后数据被消费后恢复可写入的状态时触发的事件</span><br><span class="line"></span><br><span class="line">// Function: pipe, end, cork, uncork, setDafaultEncoding, write, destory</span><br><span class="line"></span><br><span class="line">// cork / (uncork, end) 配对使用</span><br><span class="line">// cork执行后流的写入将强制写入内存缓冲区，通过uncork/end进行释放。</span><br><span class="line">// 避免不间断的写入小chunk导致性能下降</span><br><span class="line">// 指定多个cork点时，只有全部释法才会开始写入数据</span><br></pre></td></tr></table></figure>
<h2 id="可读流-stream-Readable-类"><a href="#可读流-stream-Readable-类" class="headerlink" title="可读流(stream.Readable 类)"></a>可读流(stream.Readable 类)</h2><p>两种工作模式：<strong>flowing</strong> 和 <strong>paused</strong></p>
<blockquote>
<p>flowing: 通过监听data事件获取数据片段<br>paused: 显示调用stream.read来获取数据片段<br>两者可以相互转化，具体见官方文档</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Event: &apos;close&apos;, &apos;data&apos;, &apos;end&apos;, &apos;error&apos;, &apos;readable&apos;</span><br><span class="line"></span><br><span class="line">// 下面这种方式可以代替data事件</span><br><span class="line">const rr = fs.createReadStream(&apos;foo.txt&apos;);</span><br><span class="line">rr.on(&apos;readable&apos;, () =&gt; &#123;</span><br><span class="line">    // 有一些数据可以读了</span><br><span class="line">    console.log(&apos;readable:&apos;, rr.read());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Function: isPaused, read, pipe, resume, pause</span><br><span class="line"></span><br><span class="line">// pause/resume 方法用于停止/回复流的数据输出</span><br></pre></td></tr></table></figure>
<h2 id="Duplex-与-Transform-流"><a href="#Duplex-与-Transform-流" class="headerlink" title="Duplex 与 Transform 流"></a>Duplex 与 Transform 流</h2><p>同时具备可读可写的属性和方法</p>
<blockquote>
<p>如websocket既可以向客户端写入response流，又可以读取request流</p>
</blockquote>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul>
<li>写一个http下载器，输入一个网络http资源的地址，进行文件下载保存</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://nodejs.cn/api/buffer.html#buffer_buffer" target="_blank" rel="noopener">nodejs - Buffer</a><br><a href="http://nodejs.cn/api/stream.html#stream_stream" target="_blank" rel="noopener">nodejs - Stream</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noopener">类型化数组 - TypedArray(Uint8Array)</a></p>
</div></article></div><footer class="footer"><p class="info">Welcome to mrzjd's blog!</p><div class="infobox"><ul class="contacts"><li class="contacts-i">QQ: 390303304</li><li class="contacts-i">Mail: 390303304@qq.com</li></ul><p>Powered by hexo and github. The theme is zebra-theme.</p></div></footer></body></html>